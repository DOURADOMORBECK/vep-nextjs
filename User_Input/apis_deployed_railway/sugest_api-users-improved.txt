import { Hono } from "hono";
import { cors } from "hono/cors";
import postgres from "postgres";
import bcrypt from "bcryptjs";
import { SignJWT, jwtVerify } from "jose";

// --- DB Connection ---
const db = postgres(process.env.DATABASE_URL!, {
  ssl: { rejectUnauthorized: false },
});

// --- JWT secret ---
const JWT_SECRET = process.env.JWT_SECRET || "my_secret";
const jwtSecretBytes = new TextEncoder().encode(JWT_SECRET);

// --- App ---
const app = new Hono();

// --- CORS Middleware (IMPORTANTE!) ---
app.use("/*", cors());

// --- Cria tabela de usuários se não existir ---
await db`
  CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE,
    password_hash TEXT NOT NULL,
    role TEXT DEFAULT 'user',
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_login TIMESTAMP,
    login_attempts INTEGER DEFAULT 0,
    locked_until TIMESTAMP
  )
`;

// Criar índices para melhor performance
await db`CREATE INDEX IF NOT EXISTS idx_users_email ON users(email)`;
await db`CREATE INDEX IF NOT EXISTS idx_users_is_active ON users(is_active)`;

// --- Middleware de autenticação JWT ---
async function requireAuth(c: any, next: any) {
  const auth = c.req.header("Authorization") || "";
  const token = auth.replace("Bearer ", "");
  
  if (!token) {
    return c.json({ error: "Token não fornecido" }, 401);
  }
  
  try {
    const { payload } = await jwtVerify(token, jwtSecretBytes);
    c.set("user", payload);
    await next();
  } catch (error) {
    console.error("JWT verification error:", error);
    return c.json({ error: "Token inválido ou expirado" }, 401);
  }
}

// --- Middleware de rate limiting para login ---
async function checkLoginAttempts(email: string) {
  const [user] = await db`
    SELECT login_attempts, locked_until 
    FROM users 
    WHERE email = ${email.toLowerCase()}
  `;
  
  if (!user) return true; // User doesn't exist, allow attempt
  
  // Check if account is locked
  if (user.locked_until && new Date(user.locked_until) > new Date()) {
    const minutesLeft = Math.ceil((new Date(user.locked_until).getTime() - Date.now()) / 60000);
    throw new Error(`Conta bloqueada. Tente novamente em ${minutesLeft} minutos.`);
  }
  
  // Lock account after 5 failed attempts
  if (user.login_attempts >= 5) {
    await db`
      UPDATE users 
      SET locked_until = NOW() + INTERVAL '30 minutes'
      WHERE email = ${email.toLowerCase()}
    `;
    throw new Error("Conta bloqueada devido a múltiplas tentativas de login. Tente novamente em 30 minutos.");
  }
  
  return true;
}

// --- Health check ---
app.get("/", (c) => c.text("API Users Bun OK 🚀"));

// --- Cadastro de usuário ---
app.post("/register", async (c) => {
  try {
    const { name, email, password, role } = await c.req.json();
    
    // Validação
    if (!name || !email || !password) {
      return c.json({ error: "Todos os campos são obrigatórios" }, 400);
    }
    
    // Validar formato do email
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return c.json({ error: "Email inválido" }, 400);
    }
    
    // Validar senha (mínimo 6 caracteres)
    if (password.length < 6) {
      return c.json({ error: "Senha deve ter no mínimo 6 caracteres" }, 400);
    }
    
    // Verificar se email já existe
    const exists = await db`
      SELECT 1 FROM users WHERE email = ${email.toLowerCase()}
    `;
    
    if (exists.length) {
      return c.json({ error: "E-mail já cadastrado" }, 400);
    }
    
    // Hash da senha
    const password_hash = await bcrypt.hash(password, 10);
    
    // Inserir usuário
    const [user] = await db`
      INSERT INTO users (name, email, password_hash, role)
      VALUES (
        ${name}, 
        ${email.toLowerCase()}, 
        ${password_hash},
        ${role || 'user'}
      )
      RETURNING id, name, email, role, is_active, created_at
    `;
    
    // Gerar token automaticamente após registro
    const jwt = await new SignJWT({
      id: user.id,
      email: user.email,
      name: user.name,
      role: user.role,
    })
      .setProtectedHeader({ alg: "HS256" })
      .setIssuedAt()
      .setExpirationTime("3h")
      .sign(jwtSecretBytes);
    
    return c.json({
      user,
      token: jwt,
      message: "Usuário cadastrado com sucesso"
    }, 201);
  } catch (error) {
    console.error("Register error:", error);
    return c.json({ error: "Erro ao cadastrar usuário" }, 500);
  }
});

// --- Login de usuário ---
app.post("/login", async (c) => {
  try {
    const { email, password } = await c.req.json();
    
    if (!email || !password) {
      return c.json({ error: "E-mail e senha são obrigatórios" }, 400);
    }
    
    // Check login attempts
    try {
      await checkLoginAttempts(email);
    } catch (error: any) {
      return c.json({ error: error.message }, 429);
    }
    
    // Buscar usuário
    const rows = await db`
      SELECT * FROM users 
      WHERE email = ${email.toLowerCase()} 
      AND is_active = true
    `;
    
    const user = rows[0];
    
    if (!user) {
      // Increment failed attempts
      await db`
        UPDATE users 
        SET login_attempts = login_attempts + 1
        WHERE email = ${email.toLowerCase()}
      `;
      return c.json({ error: "Usuário ou senha inválidos" }, 401);
    }
    
    // Verificar senha
    const valid = await bcrypt.compare(password, user.password_hash);
    
    if (!valid) {
      // Increment failed attempts
      await db`
        UPDATE users 
        SET login_attempts = login_attempts + 1
        WHERE id = ${user.id}
      `;
      return c.json({ error: "Usuário ou senha inválidos" }, 401);
    }
    
    // Reset login attempts and update last login
    await db`
      UPDATE users 
      SET 
        login_attempts = 0,
        locked_until = NULL,
        last_login = NOW()
      WHERE id = ${user.id}
    `;
    
    // Gerar JWT
    const jwt = await new SignJWT({
      id: user.id,
      email: user.email,
      name: user.name,
      role: user.role,
    })
      .setProtectedHeader({ alg: "HS256" })
      .setIssuedAt()
      .setExpirationTime("3h")
      .sign(jwtSecretBytes);
    
    return c.json({
      token: jwt,
      user: {
        id: user.id,
        name: user.name,
        email: user.email,
        role: user.role,
        is_active: user.is_active,
        last_login: user.last_login
      },
      message: "Login realizado com sucesso"
    });
  } catch (error) {
    console.error("Login error:", error);
    return c.json({ error: "Erro ao realizar login" }, 500);
  }
});

// --- Obter dados do usuário autenticado ---
app.get("/me", requireAuth, async (c) => {
  try {
    const authUser = c.get("user");
    
    const [user] = await db`
      SELECT id, name, email, role, is_active, created_at, updated_at, last_login
      FROM users
      WHERE id = ${authUser.id}
    `;
    
    if (!user) {
      return c.json({ error: "Usuário não encontrado" }, 404);
    }
    
    return c.json({ user });
  } catch (error) {
    console.error("Get user error:", error);
    return c.json({ error: "Erro ao buscar usuário" }, 500);
  }
});

// --- Listar todos usuários (admin only) ---
app.get("/users", requireAuth, async (c) => {
  try {
    const user = c.get("user");
    
    if (user.role !== "admin") {
      return c.json({ error: "Acesso negado" }, 403);
    }
    
    const { limit, offset, search, role, is_active } = c.req.query();
    
    let conditions = [];
    let values = [];
    let valueIndex = 1;
    
    if (search) {
      conditions.push(`(name ILIKE $${valueIndex} OR email ILIKE $${valueIndex})`);
      values.push(`%${search}%`);
      valueIndex++;
    }
    
    if (role) {
      conditions.push(`role = $${valueIndex}`);
      values.push(role);
      valueIndex++;
    }
    
    if (is_active !== undefined) {
      conditions.push(`is_active = $${valueIndex}`);
      values.push(is_active === 'true');
      valueIndex++;
    }
    
    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';
    
    const sql = `
      SELECT id, name, email, role, is_active, created_at, updated_at, last_login
      FROM users
      ${whereClause}
      ORDER BY created_at DESC
      LIMIT ${limit || 100}
      OFFSET ${offset || 0}
    `;
    
    const users = await db.unsafe(sql, ...values);
    
    // Get total count
    const countSql = `SELECT COUNT(*) as total FROM users ${whereClause}`;
    const [{ total }] = await db.unsafe(countSql, ...values);
    
    return c.json({
      users,
      total,
      limit: limit || 100,
      offset: offset || 0
    });
  } catch (error) {
    console.error("List users error:", error);
    return c.json({ error: "Erro ao listar usuários" }, 500);
  }
});

// --- Obter usuário por ID (admin only) ---
app.get("/users/:id", requireAuth, async (c) => {
  try {
    const authUser = c.get("user");
    const { id } = c.req.param();
    
    // Allow users to get their own data or admins to get any user
    if (authUser.role !== "admin" && authUser.id !== parseInt(id)) {
      return c.json({ error: "Acesso negado" }, 403);
    }
    
    const [user] = await db`
      SELECT id, name, email, role, is_active, created_at, updated_at, last_login
      FROM users
      WHERE id = ${id}
    `;
    
    if (!user) {
      return c.json({ error: "Usuário não encontrado" }, 404);
    }
    
    return c.json({ user });
  } catch (error) {
    console.error("Get user by id error:", error);
    return c.json({ error: "Erro ao buscar usuário" }, 500);
  }
});

// --- Criar usuário (admin only) ---
app.post("/users", requireAuth, async (c) => {
  try {
    const authUser = c.get("user");
    
    if (authUser.role !== "admin") {
      return c.json({ error: "Acesso negado" }, 403);
    }
    
    const { name, email, password, role, is_active } = await c.req.json();
    
    // Validação
    if (!name || !email || !password) {
      return c.json({ error: "Nome, email e senha são obrigatórios" }, 400);
    }
    
    // Verificar se email já existe
    const exists = await db`
      SELECT 1 FROM users WHERE email = ${email.toLowerCase()}
    `;
    
    if (exists.length) {
      return c.json({ error: "E-mail já cadastrado" }, 400);
    }
    
    const password_hash = await bcrypt.hash(password, 10);
    
    const [user] = await db`
      INSERT INTO users (name, email, password_hash, role, is_active)
      VALUES (
        ${name}, 
        ${email.toLowerCase()}, 
        ${password_hash},
        ${role || 'user'},
        ${is_active !== undefined ? is_active : true}
      )
      RETURNING id, name, email, role, is_active, created_at
    `;
    
    return c.json({ user, message: "Usuário criado com sucesso" }, 201);
  } catch (error) {
    console.error("Create user error:", error);
    return c.json({ error: "Erro ao criar usuário" }, 500);
  }
});

// --- Atualizar dados do usuário autenticado ---
app.put("/me", requireAuth, async (c) => {
  try {
    const { name, password, current_password } = await c.req.json();
    const user = c.get("user");
    
    if (!name && !password) {
      return c.json({ error: "Nada para atualizar" }, 400);
    }
    
    // Se está mudando a senha, verificar a senha atual
    if (password) {
      if (!current_password) {
        return c.json({ error: "Senha atual é obrigatória para mudar a senha" }, 400);
      }
      
      const [dbUser] = await db`
        SELECT password_hash FROM users WHERE id = ${user.id}
      `;
      
      const validPassword = await bcrypt.compare(current_password, dbUser.password_hash);
      if (!validPassword) {
        return c.json({ error: "Senha atual incorreta" }, 401);
      }
    }
    
    let updates: any = { updated_at: new Date() };
    
    if (name) updates.name = name;
    if (password) updates.password_hash = await bcrypt.hash(password, 10);
    
    const [updated] = await db`
      UPDATE users
      SET ${db(updates)}
      WHERE id = ${user.id}
      RETURNING id, name, email, role, is_active, updated_at
    `;
    
    if (!updated) {
      return c.json({ error: "Usuário não encontrado" }, 404);
    }
    
    return c.json({ user: updated, message: "Dados atualizados com sucesso" });
  } catch (error) {
    console.error("Update user error:", error);
    return c.json({ error: "Erro ao atualizar usuário" }, 500);
  }
});

// --- Atualizar usuário (admin only) ---
app.put("/users/:id", requireAuth, async (c) => {
  try {
    const authUser = c.get("user");
    const { id } = c.req.param();
    
    if (authUser.role !== "admin") {
      return c.json({ error: "Acesso negado" }, 403);
    }
    
    const { name, email, password, role, is_active } = await c.req.json();
    
    // Verificar se usuário existe
    const [exists] = await db`
      SELECT id FROM users WHERE id = ${id}
    `;
    
    if (!exists) {
      return c.json({ error: "Usuário não encontrado" }, 404);
    }
    
    // Se mudando email, verificar duplicação
    if (email) {
      const [duplicate] = await db`
        SELECT id FROM users 
        WHERE email = ${email.toLowerCase()} 
        AND id != ${id}
      `;
      
      if (duplicate) {
        return c.json({ error: "E-mail já está em uso" }, 400);
      }
    }
    
    let updates: any = { updated_at: new Date() };
    
    if (name) updates.name = name;
    if (email) updates.email = email.toLowerCase();
    if (password) updates.password_hash = await bcrypt.hash(password, 10);
    if (role) updates.role = role;
    if (is_active !== undefined) updates.is_active = is_active;
    
    const [updated] = await db`
      UPDATE users
      SET ${db(updates)}
      WHERE id = ${id}
      RETURNING id, name, email, role, is_active, updated_at
    `;
    
    return c.json({ user: updated, message: "Usuário atualizado com sucesso" });
  } catch (error) {
    console.error("Update user by id error:", error);
    return c.json({ error: "Erro ao atualizar usuário" }, 500);
  }
});

// --- Deletar usuário (admin only) ---
app.delete("/users/:id", requireAuth, async (c) => {
  try {
    const authUser = c.get("user");
    const { id } = c.req.param();
    
    if (authUser.role !== "admin") {
      return c.json({ error: "Acesso negado" }, 403);
    }
    
    // Não permitir que admin delete a si mesmo
    if (authUser.id === parseInt(id)) {
      return c.json({ error: "Você não pode deletar sua própria conta" }, 400);
    }
    
    // Soft delete - apenas desativa o usuário
    const [deleted] = await db`
      UPDATE users
      SET is_active = false, updated_at = NOW()
      WHERE id = ${id}
      RETURNING id
    `;
    
    if (!deleted) {
      return c.json({ error: "Usuário não encontrado" }, 404);
    }
    
    return c.json({ message: "Usuário desativado com sucesso" });
  } catch (error) {
    console.error("Delete user error:", error);
    return c.json({ error: "Erro ao deletar usuário" }, 500);
  }
});

// --- Mudar senha (requer senha atual) ---
app.post("/change-password", requireAuth, async (c) => {
  try {
    const { current_password, new_password } = await c.req.json();
    const user = c.get("user");
    
    if (!current_password || !new_password) {
      return c.json({ error: "Senha atual e nova senha são obrigatórias" }, 400);
    }
    
    if (new_password.length < 6) {
      return c.json({ error: "Nova senha deve ter no mínimo 6 caracteres" }, 400);
    }
    
    // Buscar hash da senha atual
    const [dbUser] = await db`
      SELECT password_hash FROM users WHERE id = ${user.id}
    `;
    
    const validPassword = await bcrypt.compare(current_password, dbUser.password_hash);
    if (!validPassword) {
      return c.json({ error: "Senha atual incorreta" }, 401);
    }
    
    // Atualizar senha
    const password_hash = await bcrypt.hash(new_password, 10);
    
    await db`
      UPDATE users
      SET password_hash = ${password_hash}, updated_at = NOW()
      WHERE id = ${user.id}
    `;
    
    return c.json({ message: "Senha alterada com sucesso" });
  } catch (error) {
    console.error("Change password error:", error);
    return c.json({ error: "Erro ao alterar senha" }, 500);
  }
});

// --- Resetar tentativas de login (admin only) ---
app.post("/users/:id/reset-login-attempts", requireAuth, async (c) => {
  try {
    const authUser = c.get("user");
    const { id } = c.req.param();
    
    if (authUser.role !== "admin") {
      return c.json({ error: "Acesso negado" }, 403);
    }
    
    const [updated] = await db`
      UPDATE users
      SET login_attempts = 0, locked_until = NULL
      WHERE id = ${id}
      RETURNING id
    `;
    
    if (!updated) {
      return c.json({ error: "Usuário não encontrado" }, 404);
    }
    
    return c.json({ message: "Tentativas de login resetadas com sucesso" });
  } catch (error) {
    console.error("Reset login attempts error:", error);
    return c.json({ error: "Erro ao resetar tentativas de login" }, 500);
  }
});

// --- Serve ---
Bun.serve({
  fetch: app.fetch,
  port: Number(process.env.PORT || 3000),
});