import { Hono } from "hono";
import { cors } from "hono/cors";
import postgres from "postgres";
import bcrypt from "bcryptjs";
import { SignJWT, jwtVerify } from "jose";

// --- DB Connection ---
const db = postgres(process.env.DATABASE_URL!, {
  ssl: { rejectUnauthorized: false },
});

// --- JWT secret ---
const JWT_SECRET = process.env.JWT_SECRET || "my_secret";
const jwtSecretBytes = new TextEncoder().encode(JWT_SECRET);

// --- App ---
const app = new Hono();

// --- CORS Configuration (SECURITY FIXED) ---
const isDevelopment = process.env.NODE_ENV === 'development';
const isRailwayProduction = process.env.RAILWAY_ENV === 'production';

const ALLOWED_ORIGINS = isDevelopment
  ? [
      'http://localhost:3000',
      'http://localhost:3001', 
      'http://127.0.0.1:3000',
      'http://127.0.0.1:3001'
    ]
  : [
      'https://vep-nextjs-production.up.railway.app',
      'https://vep-nextjs.up.railway.app',
      'https://*.railway.app'
    ];

// Enhanced CORS middleware with proper origin validation
app.use("/*", cors({
  origin: (origin) => {
    // Allow requests with no origin (mobile apps, curl, etc.)
    if (!origin) return true;
    
    // In development, be more permissive
    if (isDevelopment) {
      return origin.includes('localhost') || origin.includes('127.0.0.1') || ALLOWED_ORIGINS.includes(origin);
    }
    
    // In production, strict validation
    return ALLOWED_ORIGINS.some(allowed => {
      if (allowed.includes('*')) {
        // Handle wildcard patterns like *.railway.app
        const domain = allowed.replace('*.', '');
        return origin.endsWith(domain);
      }
      return origin === allowed;
    });
  },
  credentials: true, // Allow cookies to be sent
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'Accept'],
  allowedMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'PATCH'],
  exposeHeaders: ['Content-Length', 'X-Request-ID'],
  maxAge: 86400, // 24 hours
}));

// --- Cria tabela de usuários se não existir ---
await db`
  CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE,
    password_hash TEXT NOT NULL,
    role TEXT DEFAULT 'user',
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_login TIMESTAMP,
    login_attempts INTEGER DEFAULT 0,
    locked_until TIMESTAMP
  )
`;

// Criar índices para melhor performance
await db`CREATE INDEX IF NOT EXISTS idx_users_email ON users(email)`;
await db`CREATE INDEX IF NOT EXISTS idx_users_is_active ON users(is_active)`;

// --- Middleware de autenticação JWT ---
async function requireAuth(c: any, next: any) {
  const auth = c.req.header("Authorization") || "";
  const token = auth.replace("Bearer ", "");
  
  if (!token) {
    return c.json({ error: "Token não fornecido" }, 401);
  }
  
  try {
    const { payload } = await jwtVerify(token, jwtSecretBytes);
    c.set("user", payload);
    await next();
  } catch (error) {
    console.error("JWT verification error:", error);
    return c.json({ error: "Token inválido ou expirado" }, 401);
  }
}

// --- Middleware de rate limiting para login ---
async function checkLoginAttempts(email: string) {
  const [user] = await db`
    SELECT login_attempts, locked_until 
    FROM users 
    WHERE email = ${email.toLowerCase()}
  `;
  
  if (!user) return true; // User doesn't exist, allow attempt
  
  // Check if account is locked
  if (user.locked_until && new Date(user.locked_until) > new Date()) {
    const minutesLeft = Math.ceil((new Date(user.locked_until).getTime() - Date.now()) / 60000);
    throw new Error(`Conta bloqueada. Tente novamente em ${minutesLeft} minutos.`);
  }
  
  // Lock account after 5 failed attempts
  if (user.login_attempts >= 5) {
    await db`
      UPDATE users 
      SET locked_until = NOW() + INTERVAL '30 minutes'
      WHERE email = ${email.toLowerCase()}
    `;
    throw new Error("Conta bloqueada devido a múltiplas tentativas de login. Tente novamente em 30 minutos.");
  }
  
  return true;
}

// --- Health check ---
app.get("/", (c) => c.text("API Users Bun OK 🚀 - CORS Security Fixed"));

// --- Cadastro de usuário ---
app.post("/register", async (c) => {
  try {
    const { name, email, password, role } = await c.req.json();
    
    // Validação
    if (!name || !email || !password) {
      return c.json({ error: "Todos os campos são obrigatórios" }, 400);
    }
    
    // Validar formato do email
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return c.json({ error: "Email inválido" }, 400);
    }
    
    // Validar senha (mínimo 6 caracteres)
    if (password.length < 6) {
      return c.json({ error: "Senha deve ter no mínimo 6 caracteres" }, 400);
    }
    
    // Verificar se email já existe
    const exists = await db`
      SELECT 1 FROM users WHERE email = ${email.toLowerCase()}
    `;
    
    if (exists.length) {
      return c.json({ error: "E-mail já cadastrado" }, 400);
    }
    
    // Hash da senha
    const password_hash = await bcrypt.hash(password, 10);
    
    // Inserir usuário
    const [user] = await db`
      INSERT INTO users (name, email, password_hash, role)
      VALUES (
        ${name}, 
        ${email.toLowerCase()}, 
        ${password_hash},
        ${role || 'user'}
      )
      RETURNING id, name, email, role, is_active, created_at
    `;
    
    // Gerar token automaticamente após registro
    const jwt = await new SignJWT({
      id: user.id,
      email: user.email,
      name: user.name,
      role: user.role,
    })
      .setProtectedHeader({ alg: "HS256" })
      .setIssuedAt()
      .setExpirationTime("3h")
      .sign(jwtSecretBytes);
    
    return c.json({
      user,
      token: jwt,
      message: "Usuário cadastrado com sucesso"
    }, 201);
  } catch (error) {
    console.error("Register error:", error);
    return c.json({ error: "Erro ao cadastrar usuário" }, 500);
  }
});

// --- Login de usuário ---
app.post("/login", async (c) => {
  try {
    const { email, password } = await c.req.json();
    
    if (!email || !password) {
      return c.json({ error: "E-mail e senha são obrigatórios" }, 400);
    }
    
    // Check login attempts
    try {
      await checkLoginAttempts(email);
    } catch (error: any) {
      return c.json({ error: error.message }, 429);
    }
    
    // Buscar usuário
    const rows = await db`
      SELECT * FROM users 
      WHERE email = ${email.toLowerCase()} 
      AND is_active = true
    `;
    
    const user = rows[0];
    
    if (!user) {
      // Increment failed attempts
      await db`
        UPDATE users 
        SET login_attempts = login_attempts + 1
        WHERE email = ${email.toLowerCase()}
      `;
      return c.json({ error: "Usuário ou senha inválidos" }, 401);
    }
    
    // Verificar senha
    const valid = await bcrypt.compare(password, user.password_hash);
    
    if (!valid) {
      // Increment failed attempts
      await db`
        UPDATE users 
        SET login_attempts = login_attempts + 1
        WHERE id = ${user.id}
      `;
      return c.json({ error: "Usuário ou senha inválidos" }, 401);
    }
    
    // Reset login attempts and update last login
    await db`
      UPDATE users 
      SET 
        login_attempts = 0,
        locked_until = NULL,
        last_login = NOW()
      WHERE id = ${user.id}
    `;
    
    // Gerar JWT
    const jwt = await new SignJWT({
      id: user.id,
      email: user.email,
      name: user.name,
      role: user.role,
    })
      .setProtectedHeader({ alg: "HS256" })
      .setIssuedAt()
      .setExpirationTime("3h")
      .sign(jwtSecretBytes);
    
    return c.json({
      token: jwt,
      user: {
        id: user.id,
        name: user.name,
        email: user.email,
        role: user.role,
        is_active: user.is_active,
        last_login: user.last_login
      },
      message: "Login realizado com sucesso"
    });
  } catch (error) {
    console.error("Login error:", error);
    return c.json({ error: "Erro ao realizar login" }, 500);
  }
});

// ... (rest of the endpoints remain the same)

// --- Serve ---
console.log(`🚀 Users API starting on port ${process.env.PORT || 3000}`);
console.log(`📍 Environment: ${process.env.NODE_ENV || 'development'}`);
console.log(`🔒 CORS Security: ENABLED with origin validation`);
console.log(`🌐 Allowed origins: ${ALLOWED_ORIGINS.join(', ')}`);

Bun.serve({
  fetch: app.fetch,
  port: Number(process.env.PORT || 3000),
});