import { Hono } from "hono";
import postgres from "postgres";
import { jwtVerify } from "jose";

// --- DB Connection ---
const db = postgres(process.env.DATABASE_URL!, {
  ssl: { rejectUnauthorized: false },
});

// --- JWT secret ---
const JWT_SECRET = process.env.JWT_SECRET || "my_secret";
const jwtSecretBytes = new TextEncoder().encode(JWT_SECRET);

// --- App ---
const app = new Hono();

// --- Cria tabelas se n칚o existirem ---
await db`
  CREATE TABLE IF NOT EXISTS customers (
    id SERIAL PRIMARY KEY,
    code TEXT UNIQUE NOT NULL,
    name TEXT NOT NULL,
    type TEXT CHECK (type IN ('PJ', 'PF')) NOT NULL,
    document TEXT UNIQUE NOT NULL,
    email TEXT NOT NULL,
    phone TEXT,
    whatsapp TEXT,
    address TEXT NOT NULL,
    number TEXT NOT NULL,
    complement TEXT,
    neighborhood TEXT NOT NULL,
    city TEXT NOT NULL,
    state TEXT NOT NULL,
    zip_code TEXT NOT NULL,
    latitude DECIMAL(10, 8),
    longitude DECIMAL(11, 8),
    delivery_notes TEXT,
    active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  )
`;

await db`
  CREATE TABLE IF NOT EXISTS suppliers (
    id SERIAL PRIMARY KEY,
    code TEXT UNIQUE NOT NULL,
    name TEXT NOT NULL,
    type TEXT CHECK (type IN ('PJ', 'PF')) NOT NULL,
    document TEXT UNIQUE NOT NULL,
    email TEXT NOT NULL,
    phone TEXT,
    whatsapp TEXT,
    address TEXT NOT NULL,
    number TEXT NOT NULL,
    complement TEXT,
    neighborhood TEXT NOT NULL,
    city TEXT NOT NULL,
    state TEXT NOT NULL,
    zip_code TEXT NOT NULL,
    contact_name TEXT,
    categories TEXT[],
    delivery_days TEXT[],
    payment_terms TEXT,
    active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  )
`;

// --- Middleware de autentica칞칚o JWT ---
async function requireAuth(c, next) {
  const auth = c.req.header("Authorization") || "";
  const token = auth.replace("Bearer ", "");
  if (!token) return c.json({ error: "Token n칚o fornecido" }, 401);
  try {
    const { payload } = await jwtVerify(token, jwtSecretBytes);
    c.set("user", payload);
    await next();
  } catch {
    return c.json({ error: "Token inv치lido ou expirado" }, 401);
  }
}

// --- CUSTOMERS ENDPOINTS ---

// Listar todos os clientes
app.get("/customer", requireAuth, async (c) => {
  const { active, type, limit, offset } = c.req.query();
  
  let query = db`
    SELECT * FROM customers 
    WHERE 1=1
  `;
  
  if (active !== undefined) {
    query = db`${query} AND active = ${active === 'true'}`;
  }
  
  if (type) {
    query = db`${query} AND type = ${type}`;
  }
  
  query = db`${query} ORDER BY name ASC LIMIT ${limit || 100} OFFSET ${offset || 0}`;
  
  const result = await query;
  return c.json(result);
});

// Buscar cliente por ID
app.get("/customer/:id", requireAuth, async (c) => {
  const { id } = c.req.param();
  const result = await db`SELECT * FROM customers WHERE id = ${id}`;
  
  if (!result.length) {
    return c.json({ error: "Cliente n칚o encontrado" }, 404);
  }
  
  return c.json(result[0]);
});

// Buscar cliente por c칩digo
app.get("/customer/code/:code", requireAuth, async (c) => {
  const { code } = c.req.param();
  const result = await db`SELECT * FROM customers WHERE code = ${code}`;
  
  if (!result.length) {
    return c.json({ error: "Cliente n칚o encontrado" }, 404);
  }
  
  return c.json(result[0]);
});

// Criar novo cliente
app.post("/customer", requireAuth, async (c) => {
  const data = await c.req.json();
  
  // Valida칞칚o b치sica
  const requiredFields = ['code', 'name', 'type', 'document', 'email', 'address', 'number', 'neighborhood', 'city', 'state', 'zip_code'];
  for (const field of requiredFields) {
    if (!data[field]) {
      return c.json({ error: `Campo ${field} 칠 obrigat칩rio` }, 400);
    }
  }
  
  // Verifica se c칩digo ou documento j치 existe
  const existing = await db`
    SELECT id FROM customers 
    WHERE code = ${data.code} OR document = ${data.document}
  `;
  
  if (existing.length) {
    return c.json({ error: "Cliente com este c칩digo ou documento j치 existe" }, 400);
  }
  
  try {
    const [customer] = await db`
      INSERT INTO customers (
        code, name, type, document, email, phone, whatsapp,
        address, number, complement, neighborhood, city, state, zip_code,
        latitude, longitude, delivery_notes, active
      ) VALUES (
        ${data.code}, ${data.name}, ${data.type}, ${data.document}, 
        ${data.email}, ${data.phone || null}, ${data.whatsapp || null},
        ${data.address}, ${data.number}, ${data.complement || null}, 
        ${data.neighborhood}, ${data.city}, ${data.state}, ${data.zip_code},
        ${data.latitude || null}, ${data.longitude || null}, 
        ${data.delivery_notes || null}, ${data.active !== false}
      )
      RETURNING *
    `;
    
    return c.json(customer, 201);
  } catch (error) {
    return c.json({ error: "Erro ao criar cliente" }, 500);
  }
});

// Atualizar cliente
app.put("/customer/:id", requireAuth, async (c) => {
  const { id } = c.req.param();
  const data = await c.req.json();
  
  // Verifica se cliente existe
  const existing = await db`SELECT id FROM customers WHERE id = ${id}`;
  if (!existing.length) {
    return c.json({ error: "Cliente n칚o encontrado" }, 404);
  }
  
  // Se mudando c칩digo ou documento, verifica duplica칞칚o
  if (data.code || data.document) {
    const duplicate = await db`
      SELECT id FROM customers 
      WHERE (code = ${data.code} OR document = ${data.document})
      AND id != ${id}
    `;
    
    if (duplicate.length) {
      return c.json({ error: "C칩digo ou documento j치 em uso" }, 400);
    }
  }
  
  try {
    const [updated] = await db`
      UPDATE customers
      SET 
        code = COALESCE(${data.code}, code),
        name = COALESCE(${data.name}, name),
        type = COALESCE(${data.type}, type),
        document = COALESCE(${data.document}, document),
        email = COALESCE(${data.email}, email),
        phone = COALESCE(${data.phone}, phone),
        whatsapp = COALESCE(${data.whatsapp}, whatsapp),
        address = COALESCE(${data.address}, address),
        number = COALESCE(${data.number}, number),
        complement = COALESCE(${data.complement}, complement),
        neighborhood = COALESCE(${data.neighborhood}, neighborhood),
        city = COALESCE(${data.city}, city),
        state = COALESCE(${data.state}, state),
        zip_code = COALESCE(${data.zip_code}, zip_code),
        latitude = COALESCE(${data.latitude}, latitude),
        longitude = COALESCE(${data.longitude}, longitude),
        delivery_notes = COALESCE(${data.delivery_notes}, delivery_notes),
        active = COALESCE(${data.active}, active),
        updated_at = CURRENT_TIMESTAMP
      WHERE id = ${id}
      RETURNING *
    `;
    
    return c.json(updated);
  } catch (error) {
    return c.json({ error: "Erro ao atualizar cliente" }, 500);
  }
});

// Deletar cliente (soft delete)
app.delete("/customer/:id", requireAuth, async (c) => {
  const { id } = c.req.param();
  
  const [result] = await db`
    UPDATE customers 
    SET active = false, updated_at = CURRENT_TIMESTAMP
    WHERE id = ${id}
    RETURNING id
  `;
  
  if (!result) {
    return c.json({ error: "Cliente n칚o encontrado" }, 404);
  }
  
  return c.json({ message: "Cliente desativado com sucesso" });
});

// --- SUPPLIERS ENDPOINTS ---

// Listar todos os fornecedores
app.get("/supplier", requireAuth, async (c) => {
  const { active, type, category, limit, offset } = c.req.query();
  
  let query = db`
    SELECT * FROM suppliers 
    WHERE 1=1
  `;
  
  if (active !== undefined) {
    query = db`${query} AND active = ${active === 'true'}`;
  }
  
  if (type) {
    query = db`${query} AND type = ${type}`;
  }
  
  if (category) {
    query = db`${query} AND ${category} = ANY(categories)`;
  }
  
  query = db`${query} ORDER BY name ASC LIMIT ${limit || 100} OFFSET ${offset || 0}`;
  
  const result = await query;
  return c.json(result);
});

// Buscar fornecedor por ID
app.get("/supplier/:id", requireAuth, async (c) => {
  const { id } = c.req.param();
  const result = await db`SELECT * FROM suppliers WHERE id = ${id}`;
  
  if (!result.length) {
    return c.json({ error: "Fornecedor n칚o encontrado" }, 404);
  }
  
  return c.json(result[0]);
});

// Buscar fornecedor por c칩digo
app.get("/supplier/code/:code", requireAuth, async (c) => {
  const { code } = c.req.param();
  const result = await db`SELECT * FROM suppliers WHERE code = ${code}`;
  
  if (!result.length) {
    return c.json({ error: "Fornecedor n칚o encontrado" }, 404);
  }
  
  return c.json(result[0]);
});

// Criar novo fornecedor
app.post("/supplier", requireAuth, async (c) => {
  const data = await c.req.json();
  
  // Valida칞칚o b치sica
  const requiredFields = ['code', 'name', 'type', 'document', 'email', 'address', 'number', 'neighborhood', 'city', 'state', 'zip_code'];
  for (const field of requiredFields) {
    if (!data[field]) {
      return c.json({ error: `Campo ${field} 칠 obrigat칩rio` }, 400);
    }
  }
  
  // Verifica se c칩digo ou documento j치 existe
  const existing = await db`
    SELECT id FROM suppliers 
    WHERE code = ${data.code} OR document = ${data.document}
  `;
  
  if (existing.length) {
    return c.json({ error: "Fornecedor com este c칩digo ou documento j치 existe" }, 400);
  }
  
  try {
    const [supplier] = await db`
      INSERT INTO suppliers (
        code, name, type, document, email, phone, whatsapp,
        address, number, complement, neighborhood, city, state, zip_code,
        contact_name, categories, delivery_days, payment_terms, active
      ) VALUES (
        ${data.code}, ${data.name}, ${data.type}, ${data.document}, 
        ${data.email}, ${data.phone || null}, ${data.whatsapp || null},
        ${data.address}, ${data.number}, ${data.complement || null}, 
        ${data.neighborhood}, ${data.city}, ${data.state}, ${data.zip_code},
        ${data.contact_name || null}, ${data.categories || []}, 
        ${data.delivery_days || []}, ${data.payment_terms || null}, 
        ${data.active !== false}
      )
      RETURNING *
    `;
    
    return c.json(supplier, 201);
  } catch (error) {
    return c.json({ error: "Erro ao criar fornecedor" }, 500);
  }
});

// Atualizar fornecedor
app.put("/supplier/:id", requireAuth, async (c) => {
  const { id } = c.req.param();
  const data = await c.req.json();
  
  // Verifica se fornecedor existe
  const existing = await db`SELECT id FROM suppliers WHERE id = ${id}`;
  if (!existing.length) {
    return c.json({ error: "Fornecedor n칚o encontrado" }, 404);
  }
  
  // Se mudando c칩digo ou documento, verifica duplica칞칚o
  if (data.code || data.document) {
    const duplicate = await db`
      SELECT id FROM suppliers 
      WHERE (code = ${data.code} OR document = ${data.document})
      AND id != ${id}
    `;
    
    if (duplicate.length) {
      return c.json({ error: "C칩digo ou documento j치 em uso" }, 400);
    }
  }
  
  try {
    const [updated] = await db`
      UPDATE suppliers
      SET 
        code = COALESCE(${data.code}, code),
        name = COALESCE(${data.name}, name),
        type = COALESCE(${data.type}, type),
        document = COALESCE(${data.document}, document),
        email = COALESCE(${data.email}, email),
        phone = COALESCE(${data.phone}, phone),
        whatsapp = COALESCE(${data.whatsapp}, whatsapp),
        address = COALESCE(${data.address}, address),
        number = COALESCE(${data.number}, number),
        complement = COALESCE(${data.complement}, complement),
        neighborhood = COALESCE(${data.neighborhood}, neighborhood),
        city = COALESCE(${data.city}, city),
        state = COALESCE(${data.state}, state),
        zip_code = COALESCE(${data.zip_code}, zip_code),
        contact_name = COALESCE(${data.contact_name}, contact_name),
        categories = COALESCE(${data.categories}, categories),
        delivery_days = COALESCE(${data.delivery_days}, delivery_days),
        payment_terms = COALESCE(${data.payment_terms}, payment_terms),
        active = COALESCE(${data.active}, active),
        updated_at = CURRENT_TIMESTAMP
      WHERE id = ${id}
      RETURNING *
    `;
    
    return c.json(updated);
  } catch (error) {
    return c.json({ error: "Erro ao atualizar fornecedor" }, 500);
  }
});

// Deletar fornecedor (soft delete)
app.delete("/supplier/:id", requireAuth, async (c) => {
  const { id } = c.req.param();
  
  const [result] = await db`
    UPDATE suppliers 
    SET active = false, updated_at = CURRENT_TIMESTAMP
    WHERE id = ${id}
    RETURNING id
  `;
  
  if (!result) {
    return c.json({ error: "Fornecedor n칚o encontrado" }, 404);
  }
  
  return c.json({ message: "Fornecedor desativado com sucesso" });
});

// --- Health check ---
app.get("/", (c) => c.text("API Customers Bun OK 游"));

// --- Serve ---
Bun.serve({
  fetch: app.fetch,
  port: Number(process.env.PORT || 3000),
});

export default app;