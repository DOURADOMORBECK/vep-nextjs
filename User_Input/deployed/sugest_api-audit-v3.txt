import { Hono } from "hono";
import { cors } from "hono/cors";
import postgres from "postgres";

// --- DB Connection ---
const db = postgres(process.env.DATABASE_URL!, {
  ssl: { rejectUnauthorized: false },
});

// --- App ---
const app = new Hono();

// --- CORS Middleware ---
app.use("/*", cors());

// --- Create table if not exists ---
await db`
  CREATE TABLE IF NOT EXISTS audit_logs (
    id SERIAL PRIMARY KEY,
    user_id TEXT NOT NULL,
    action TEXT NOT NULL,
    resource_type TEXT,
    resource_id TEXT,
    old_values JSONB,
    new_values JSONB,
    ip_address TEXT,
    user_agent TEXT,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    severity TEXT DEFAULT 'INFO'
  )
`;

// Create indexes for better performance
await db`CREATE INDEX IF NOT EXISTS idx_audit_logs_user_id ON audit_logs(user_id)`;
await db`CREATE INDEX IF NOT EXISTS idx_audit_logs_action ON audit_logs(action)`;
await db`CREATE INDEX IF NOT EXISTS idx_audit_logs_resource ON audit_logs(resource_type, resource_id)`;
await db`CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp)`;
await db`CREATE INDEX IF NOT EXISTS idx_audit_logs_severity ON audit_logs(severity)`;

// --- Health check endpoint ---
app.get('/health', async (c) => {
  try {
    // Test database connection
    await db`SELECT 1`;
    return c.json({ 
      status: 'healthy',
      service: 'audit-api',
      timestamp: new Date().toISOString(),
      database: 'connected'
    });
  } catch (error: any) {
    return c.json({ 
      status: 'unhealthy',
      service: 'audit-api',
      timestamp: new Date().toISOString(),
      database: 'disconnected',
      error: error.message
    }, 503);
  }
});

// --- Root endpoint ---
app.get("/", (c) => c.text("API Audit Bun OK ðŸš€ - V3"));

// --- Audit Endpoints ---

// Create new audit log entry
app.post("/audit/logs", async (c) => {
  try {
    const data = await c.req.json();
    
    // Validate required fields
    if (!data.user_id || !data.action) {
      return c.json({ error: "user_id and action are required" }, 400);
    }
    
    const [audit] = await db`
      INSERT INTO audit_logs (
        user_id,
        action,
        resource_type,
        resource_id,
        old_values,
        new_values,
        ip_address,
        user_agent,
        timestamp,
        severity
      ) VALUES (
        ${data.user_id},
        ${data.action},
        ${data.resource_type || null},
        ${data.resource_id || null},
        ${JSON.stringify(data.old_values || {})},
        ${JSON.stringify(data.new_values || {})},
        ${c.req.header('x-forwarded-for') || c.req.header('x-real-ip') || 'unknown'},
        ${c.req.header('user-agent') || 'unknown'},
        ${data.timestamp || new Date()},
        ${data.severity || 'INFO'}
      )
      RETURNING *
    `;
    
    return c.json(audit, 201);
  } catch (error) {
    console.error("Error creating audit log:", error);
    return c.json({ error: "Error creating audit log" }, 500);
  }
});

// Get all audit logs with filters
app.get("/audit/logs", async (c) => {
  try {
    const { user_id, action, resource_type, severity, startDate, endDate, limit, offset } = c.req.query();
    
    let conditions = [];
    let values = [];
    let valueIndex = 1;
    
    if (user_id) {
      conditions.push(`user_id = $${valueIndex++}`);
      values.push(user_id);
    }
    
    if (action) {
      conditions.push(`action = $${valueIndex++}`);
      values.push(action);
    }
    
    if (resource_type) {
      conditions.push(`resource_type = $${valueIndex++}`);
      values.push(resource_type);
    }
    
    if (severity) {
      conditions.push(`severity = $${valueIndex++}`);
      values.push(severity);
    }
    
    if (startDate) {
      conditions.push(`timestamp >= $${valueIndex++}`);
      values.push(startDate);
    }
    
    if (endDate) {
      conditions.push(`timestamp <= $${valueIndex++}`);
      values.push(endDate);
    }
    
    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';
    
    const query = `
      SELECT * FROM audit_logs 
      ${whereClause}
      ORDER BY timestamp DESC 
      LIMIT ${limit || 100} 
      OFFSET ${offset || 0}
    `;
    
    const result = await db.unsafe(query, ...values);
    return c.json(result);
  } catch (error) {
    console.error("Error fetching audit logs:", error);
    return c.json({ error: "Error fetching audit logs" }, 500);
  }
});

// Get audit log by ID
app.get("/audit/logs/:id", async (c) => {
  try {
    const { id } = c.req.param();
    const result = await db`
      SELECT * FROM audit_logs 
      WHERE id = ${id}
    `;
    
    if (!result.length) {
      return c.json({ error: "Audit log not found" }, 404);
    }
    
    return c.json(result[0]);
  } catch (error) {
    console.error("Error fetching audit log:", error);
    return c.json({ error: "Error fetching audit log" }, 500);
  }
});

// Get audit logs by user
app.get("/audit/logs/user/:userId", async (c) => {
  try {
    const { userId } = c.req.param();
    const { limit, offset } = c.req.query();
    
    const result = await db`
      SELECT * FROM audit_logs 
      WHERE user_id = ${userId}
      ORDER BY timestamp DESC
      LIMIT ${limit || 100}
      OFFSET ${offset || 0}
    `;
    
    return c.json(result);
  } catch (error) {
    console.error("Error fetching user audit logs:", error);
    return c.json({ error: "Error fetching user audit logs" }, 500);
  }
});

// Get audit logs by action
app.get("/audit/logs/action/:action", async (c) => {
  try {
    const { action } = c.req.param();
    const { limit, offset } = c.req.query();
    
    const result = await db`
      SELECT * FROM audit_logs 
      WHERE action = ${action}
      ORDER BY timestamp DESC
      LIMIT ${limit || 100}
      OFFSET ${offset || 0}
    `;
    
    return c.json(result);
  } catch (error) {
    console.error("Error fetching logs by action:", error);
    return c.json({ error: "Error fetching logs by action" }, 500);
  }
});

// Get audit logs by resource
app.get("/audit/logs/resource/:resourceType/:resourceId", async (c) => {
  try {
    const { resourceType, resourceId } = c.req.param();
    const { limit, offset } = c.req.query();
    
    const result = await db`
      SELECT * FROM audit_logs 
      WHERE resource_type = ${resourceType}
      AND resource_id = ${resourceId}
      ORDER BY timestamp DESC
      LIMIT ${limit || 100}
      OFFSET ${offset || 0}
    `;
    
    return c.json(result);
  } catch (error) {
    console.error("Error fetching logs by resource:", error);
    return c.json({ error: "Error fetching logs by resource" }, 500);
  }
});

// Get audit logs by date range
app.get("/audit/logs/date-range", async (c) => {
  try {
    const { start, end, limit, offset } = c.req.query();
    
    if (!start || !end) {
      return c.json({ error: "Missing start/end dates" }, 400);
    }

    const result = await db`
      SELECT * FROM audit_logs 
      WHERE timestamp BETWEEN ${start} AND ${end} 
      ORDER BY timestamp DESC
      LIMIT ${limit || 100}
      OFFSET ${offset || 0}
    `;
    
    return c.json(result);
  } catch (error) {
    console.error("Error fetching logs by date range:", error);
    return c.json({ error: "Error fetching logs by date range" }, 500);
  }
});

// Get audit statistics
app.get("/audit/stats", async (c) => {
  try {
    const total = await db`SELECT COUNT(*) AS total FROM audit_logs`;
    
    const byUser = await db`
      SELECT user_id, COUNT(*) as count 
      FROM audit_logs 
      GROUP BY user_id 
      ORDER BY count DESC
      LIMIT 10
    `;
    
    const byAction = await db`
      SELECT action, COUNT(*) as count 
      FROM audit_logs 
      GROUP BY action 
      ORDER BY count DESC
    `;
    
    const bySeverity = await db`
      SELECT severity, COUNT(*) as count 
      FROM audit_logs 
      GROUP BY severity 
      ORDER BY 
        CASE severity 
          WHEN 'CRITICAL' THEN 1 
          WHEN 'ERROR' THEN 2 
          WHEN 'WARNING' THEN 3 
          WHEN 'INFO' THEN 4 
          ELSE 5 
        END
    `;
    
    const recent = await db`
      SELECT COUNT(*) AS recent 
      FROM audit_logs 
      WHERE timestamp > NOW() - INTERVAL '24 hours'
    `;
    
    const critical = await db`
      SELECT COUNT(*) AS critical 
      FROM audit_logs 
      WHERE severity IN ('CRITICAL', 'ERROR')
      AND timestamp > NOW() - INTERVAL '24 hours'
    `;

    return c.json({
      total: total[0]?.total || 0,
      recent24h: recent[0]?.recent || 0,
      critical24h: critical[0]?.critical || 0,
      byUser,
      byAction,
      bySeverity,
    });
  } catch (error) {
    console.error("Error fetching audit stats:", error);
    return c.json({ error: "Error fetching statistics" }, 500);
  }
});

// Get security alerts (high severity logs)
app.get("/audit/security-alerts", async (c) => {
  try {
    const { limit, offset } = c.req.query();
    
    const result = await db`
      SELECT * FROM audit_logs 
      WHERE severity IN ('CRITICAL', 'ERROR')
      ORDER BY timestamp DESC
      LIMIT ${limit || 50}
      OFFSET ${offset || 0}
    `;
    
    return c.json(result);
  } catch (error) {
    console.error("Error fetching security alerts:", error);
    return c.json({ error: "Error fetching security alerts" }, 500);
  }
});

// Delete old audit logs (cleanup endpoint)
app.delete("/audit/logs/cleanup", async (c) => {
  try {
    const { days } = c.req.query();
    const daysToKeep = days || 365; // Keep audit logs for 1 year by default
    
    const result = await db`
      DELETE FROM audit_logs 
      WHERE timestamp < NOW() - INTERVAL '${daysToKeep} days'
      AND severity NOT IN ('CRITICAL', 'ERROR')
      RETURNING id
    `;
    
    return c.json({ 
      message: `Deleted ${result.length} non-critical audit logs older than ${daysToKeep} days` 
    });
  } catch (error) {
    console.error("Error cleaning up audit logs:", error);
    return c.json({ error: "Error cleaning up audit logs" }, 500);
  }
});

// --- Serve ---
Bun.serve({
  fetch: app.fetch,
  port: Number(process.env.PORT || 3000),
});