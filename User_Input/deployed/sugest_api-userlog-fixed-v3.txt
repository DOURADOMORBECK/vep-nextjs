import { Hono } from "hono";
import { cors } from "hono/cors";
import postgres from "postgres";

// --- DB Connection ---
const db = postgres(process.env.DATABASE_URL!, {
  ssl: { rejectUnauthorized: false },
});

// --- App ---
const app = new Hono();

// --- CORS Middleware ---
app.use("/*", cors());

// --- Create table if not exists ---
await db`
  CREATE TABLE IF NOT EXISTS user_logs (
    id SERIAL PRIMARY KEY,
    user_id TEXT NOT NULL,
    action TEXT NOT NULL,
    module TEXT NOT NULL,
    details JSONB,
    ip_address TEXT,
    user_agent TEXT,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  )
`;

// Create index for better performance
await db`CREATE INDEX IF NOT EXISTS idx_user_logs_user_id ON user_logs(user_id)`;
await db`CREATE INDEX IF NOT EXISTS idx_user_logs_action ON user_logs(action)`;
await db`CREATE INDEX IF NOT EXISTS idx_user_logs_module ON user_logs(module)`;
await db`CREATE INDEX IF NOT EXISTS idx_user_logs_timestamp ON user_logs(timestamp)`;

// --- Health Check ---
app.get("/", (c) => c.text("API UserLog V3 Bun OK ðŸš€"));

// --- Health endpoint ---
app.get('/health', async (c) => {
  try {
    await db`SELECT 1`;
    return c.json({ 
      status: 'healthy',
      service: 'userlog-api',
      timestamp: new Date().toISOString(),
      database: 'connected'
    });
  } catch (error: any) {
    return c.json({ 
      status: 'unhealthy',
      service: 'userlog-api',
      timestamp: new Date().toISOString(),
      database: 'disconnected',
      error: error.message
    }, 503);
  }
});

// --- UserLog Endpoints ---

// Create new log entry
app.post("/logs", async (c) => {
  try {
    const data = await c.req.json();
    
    // Validate required fields
    if (!data.action || !data.userId) {
      return c.json({ error: "action and userId are required" }, 400);
    }
    
    const [log] = await db`
      INSERT INTO user_logs (
        user_id,
        action,
        module,
        details,
        ip_address,
        user_agent,
        timestamp
      ) VALUES (
        ${data.userId},
        ${data.action},
        ${data.module || 'GENERAL'},
        ${JSON.stringify(data.details || {})},
        ${c.req.header('x-forwarded-for') || c.req.header('x-real-ip') || 'unknown'},
        ${c.req.header('user-agent') || 'unknown'},
        ${data.timestamp || new Date()}
      )
      RETURNING *
    `;
    
    return c.json(log, 201);
  } catch (error) {
    console.error("Error creating log:", error);
    return c.json({ error: "Error creating log entry" }, 500);
  }
});

// Get all logs with filters
app.get("/logs", async (c) => {
  try {
    const { userId, action, module, startDate, endDate, limit, offset } = c.req.query();
    
    let conditions = [];
    let values = [];
    let valueIndex = 1;
    
    if (userId) {
      conditions.push(`user_id = $${valueIndex++}`);
      values.push(userId);
    }
    
    if (action) {
      conditions.push(`action = $${valueIndex++}`);
      values.push(action);
    }
    
    if (module) {
      conditions.push(`module = $${valueIndex++}`);
      values.push(module);
    }
    
    if (startDate) {
      conditions.push(`timestamp >= $${valueIndex++}`);
      values.push(startDate);
    }
    
    if (endDate) {
      conditions.push(`timestamp <= $${valueIndex++}`);
      values.push(endDate);
    }
    
    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';
    
    const query = `
      SELECT * FROM user_logs 
      ${whereClause}
      ORDER BY timestamp DESC 
      LIMIT ${limit || 100} 
      OFFSET ${offset || 0}
    `;
    
    const result = await db.unsafe(query, ...values);
    return c.json(result);
  } catch (error) {
    console.error("Error fetching logs:", error);
    return c.json({ error: "Error fetching logs" }, 500);
  }
});

// Get log by ID
app.get("/logs/:id", async (c) => {
  try {
    const { id } = c.req.param();
    const result = await db`
      SELECT * FROM user_logs 
      WHERE id = ${id}
    `;
    
    if (!result.length) {
      return c.json({ error: "Log not found" }, 404);
    }
    
    return c.json(result[0]);
  } catch (error) {
    console.error("Error fetching log:", error);
    return c.json({ error: "Error fetching log" }, 500);
  }
});

// Get logs by user
app.get("/logs/user/:userId", async (c) => {
  try {
    const { userId } = c.req.param();
    const { limit, offset } = c.req.query();
    
    const result = await db`
      SELECT * FROM user_logs 
      WHERE user_id = ${userId}
      ORDER BY timestamp DESC
      LIMIT ${limit || 100}
      OFFSET ${offset || 0}
    `;
    
    return c.json(result);
  } catch (error) {
    console.error("Error fetching user logs:", error);
    return c.json({ error: "Error fetching user logs" }, 500);
  }
});

// Get logs by action
app.get("/logs/action/:action", async (c) => {
  try {
    const { action } = c.req.param();
    const { limit, offset } = c.req.query();
    
    const result = await db`
      SELECT * FROM user_logs 
      WHERE action = ${action}
      ORDER BY timestamp DESC
      LIMIT ${limit || 100}
      OFFSET ${offset || 0}
    `;
    
    return c.json(result);
  } catch (error) {
    console.error("Error fetching logs by action:", error);
    return c.json({ error: "Error fetching logs by action" }, 500);
  }
});

// Get logs by module
app.get("/logs/module/:module", async (c) => {
  try {
    const { module } = c.req.param();
    const { limit, offset } = c.req.query();
    
    const result = await db`
      SELECT * FROM user_logs 
      WHERE module = ${module}
      ORDER BY timestamp DESC
      LIMIT ${limit || 100}
      OFFSET ${offset || 0}
    `;
    
    return c.json(result);
  } catch (error) {
    console.error("Error fetching logs by module:", error);
    return c.json({ error: "Error fetching logs by module" }, 500);
  }
});

// Get log statistics
app.get("/logs/stats", async (c) => {
  try {
    const totalLogs = await db`SELECT COUNT(*) AS total FROM user_logs`;
    
    const logsByAction = await db`
      SELECT action, COUNT(*) as count 
      FROM user_logs 
      GROUP BY action 
      ORDER BY count DESC
      LIMIT 10
    `;
    
    const logsByModule = await db`
      SELECT module, COUNT(*) as count 
      FROM user_logs 
      GROUP BY module 
      ORDER BY count DESC
    `;
    
    const logsByUser = await db`
      SELECT user_id, COUNT(*) as count 
      FROM user_logs 
      GROUP BY user_id 
      ORDER BY count DESC
      LIMIT 10
    `;
    
    const recentLogs = await db`
      SELECT COUNT(*) AS recent 
      FROM user_logs 
      WHERE timestamp > NOW() - INTERVAL '24 hours'
    `;
    
    return c.json({
      total: totalLogs[0]?.total || 0,
      recent24h: recentLogs[0]?.recent || 0,
      byAction: logsByAction,
      byModule: logsByModule,
      topUsers: logsByUser
    });
  } catch (error) {
    console.error("Error fetching log stats:", error);
    return c.json({ error: "Error fetching statistics" }, 500);
  }
});

// Delete old logs (cleanup endpoint)
app.delete("/logs/cleanup", async (c) => {
  try {
    const { days } = c.req.query();
    const daysToKeep = days || 90;
    
    const result = await db`
      DELETE FROM user_logs 
      WHERE timestamp < NOW() - INTERVAL '${daysToKeep} days'
      RETURNING id
    `;
    
    return c.json({ 
      message: `Deleted ${result.length} logs older than ${daysToKeep} days` 
    });
  } catch (error) {
    console.error("Error cleaning up logs:", error);
    return c.json({ error: "Error cleaning up logs" }, 500);
  }
});

// --- Serve ---
Bun.serve({
  fetch: app.fetch,
  port: Number(process.env.PORT || 3000),
});